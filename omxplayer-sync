#!/usr/bin/env python
#
# omxplayer-sync
#
# Copyright 2013, Simon Josi
# Simon Josi me(at)yokto(dot)net
#
# This program is free software; you can redistribute 
# it and/or modify it under the terms of the GNU 
# General Public License version 3 as published by 
# the Free Software Foundation.
#

import re
import os
import sys
import math
import socket
import pexpect
import signal
import collections
import threading
from time import sleep, time
from optparse import OptionParser, BadOptionError, AmbiguousOptionError

OMXPLAYER = 'omxplayer'
PORT = 1666
TOLERANCE = 0.3
SEEK_SIZE = 30
REGEX_STATUS = re.compile(r"M:\s*(\d+) ")
REGEX_DONE = re.compile(r"have a nice day.*")

class PassThroughOptionParser(OptionParser):
    """
    An unknown option pass-through implementation of OptionParser.

    When unknown arguments are encountered, bundle with largs and try again,
    until rargs is depleted.  

    sys.exit(status) will still be called if a known argument is passed
    incorrectly (e.g. missing arguments or bad argument types, etc.)        
    """
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self,largs,rargs,values)
            except (BadOptionError,AmbiguousOptionError), e:
                largs.append(e.opt_str)

class OMXPlayerSync():
    def __init__(self):
        self.sock = self.init_socket()

        self.options = None
        self.omxplayer_options = []
        self.filenames = []
        self.filename = ''
        self.position_local = 0.0
        self.position_master = 0.0
        self.filename_master = ''
        self.process = None

        signal.signal(signal.SIGINT, self.kill_omxplayer_and_exit)

    def run(self):
        p = PassThroughOptionParser()
        p.add_option('--master', '-m', action='store_true')
        p.add_option('--slave', '-l', action='store_true')
        p.add_option('--destination', '-x', default='255.255.255.255')
        p.add_option('--loop', '-u', action='store_true')
        p.add_option('--verbose', '-v', action='store_true')
        self.options, arguments = p.parse_args()

        for argument in arguments:
            if argument.startswith('-'):
                self.omxplayer_options.append(argument)
            else:
                self.filenames.append(argument)

        if self.options.master:
            self.socket_enable_broadcast()
            self.socket_connect(self.options.destination)

        if self.options.slave:
            read_thread = threading.Thread(target=self.read_position_master)
            read_thread.daemon = True
            read_thread.start()
            sleep(0.1)

        while True:
            for filename in self.filenames:
                if self.options.slave:
                    sleep(0.1)
                    if self.filename_master in self.filenames:
                        filename = self.filename_master

                self.play_file(filename)

            if not self.options.loop: break

    def play_file(self, filename):
        self.filename = filename
        self.position_local = 0.0

        if self.options.master:
            self.send_position_local()
            sleep(0.1)

        if self.options.slave:
            wait_for_sync = False
            wait_after_sync = False
            deviations = collections.deque(maxlen=25)

        self.process = pexpect.spawn('%s -s %s %s' % (
            OMXPLAYER, ' '.join(self.omxplayer_options), self.filename), timeout=0.01)

        while True:
            if not self.read_position_local():
                break

            if self.options.master:
                self.send_position_local()
                if self.options.verbose:
                    sys.stdout.write("local: %.2f %.0f\n" % (
                        self.position_local, math.modf(self.position_local)[0]*100/4))

            if self.options.slave:
                self.sync(wait_for_sync, wait_after_sync, deviations)

        self.kill_omxplayer()

    def read_position_local(self):
        eof = False
        while True:
            index = self.process.expect([
                REGEX_STATUS,
                pexpect.TIMEOUT,
                pexpect.EOF,
                REGEX_DONE,
            ])
            if index == 1:
                break
            elif index in (2,3):
                if self.options.verbose:
                    print "omxplayer has ended..."
                eof = True
                break
            else:
                self.position_local = (float(self.process.match.group(1)) / 1000000)
        return not eof

    def init_socket(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        sock.bind(('0.0.0.0', PORT))
        return sock

    def kill_omxplayer(self):
         try:
             os.kill(-self.process.pid, 15)
         except:
             pass
         try:
             self.process.kill(15)
         except:
             pass

    def kill_omxplayer_and_exit(self, signum, frame):
        self.kill_omxplayer()
        sys.exit(0)

    #
    # master specific
    #
    def socket_enable_broadcast(self):
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

    def socket_connect(self, destination):
        try:
            self.sock.connect((destination, PORT))
        except:
            print "connect: Network is unreachable"
            pass

    def send_position_local(self):
        try:
            self.sock.send('%s%%%s' % (str(self.position_local), self.filename))
        except socket.error:
            pass

    #
    # slave
    #
    def read_position_master(self):
        while True:
            data = self.sock.recvfrom(1024)[0].split('%', 1)
            self.position_master = float(data[0])
            self.filename_master = data[1]

    def sync(self, wait_for_sync, wait_after_sync, deviations):
        deviation = self.position_master - self.position_local
        deviations.append(deviation)
        moving_deviation = sum(list(deviations)) / float(len(list(deviations)))
	if self.options.verbose:
	    print "local: %.2f master: %.2f deviation: %.2f moving_deviation: %.2f wait_for_sync: %r" % (
		self.position_local, self.position_master, deviation, moving_deviation, wait_for_sync)

        if wait_for_sync:
            if moving_deviation >= -0.1 and moving_deviation < 0.1:
                process.send('p')
                if options.verbose:
                    print "we are sync, play..."
                wait_for_sync = False
                wait_after_sync = time()

            return
        
        if wait_after_sync:
            if (time() - wait_after_sync) > 5:
                 wait_after_sync = False

            return

        if abs(moving_deviation) > TOLERANCE \
        and self.position_local > 5.0 \
        and self.position_master > 5.0 \
        and self.filename == self.filename_master:
            sleep(0.2)
            if position_local < position_master :
                if options.verbose:
                    print "seek forward..."
                process.send('\x1B[C')
            elif position_local > (position_master + 15 + SEEK_SIZE):
                if options.verbose:
                    print "seek backwards..."
                process.send('\x1B[D')
            else:
                process.send('p')
                wait_for_sync=True
            sleep(0.2)

if __name__ == '__main__':
    OMXPlayerSync().run()
